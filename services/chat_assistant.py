import io
import re
import shutil
import subprocess
import zipfile
import os
from typing import Any, Dict, List
from fastapi import HTTPException, UploadFile # Keep HTTPException if used elsewhere, UploadFile is used

from db_connection.qdrant import QdrantDBManager, COLLECTION_NAME 
from dto.value_objects import ChunkResponse, CodeChunk, QueryResponse, UserQueryAnalysisType, LLMQueryResponse, CodeReference
from langugae_processors.php_processor import LaravelProcessor 
from model_interfaces.embedding_model import EmbeddingModel
from model_interfaces.gemini_model import GeminiModel

import patch
from unidiff import PatchSet
from typing import List, Dict, Any
from difflib import SequenceMatcher

class ChatAssistantService():
    """
    Service class for handling chat assistant operations.
    Service class for handling chat assistant operations.
    This will encapsulate the logic for uploading, processing,
    and querying codebases.
    """
    def __init__(self):
        self.embedding_model = EmbeddingModel()
        self.vector_store = QdrantDBManager()
        try:
            self.llm_model = GeminiModel()
        except Exception as e: 
            print(f"Failed to initialize Gemini Model: {e}. LLM features will be unavailable.")
            self.llm_model = None
        pass

    async def process_uploaded_zip(self, zip_file: UploadFile, description: str) -> list[str]:
        """
        Handles the end-to-end process of receiving a zip file,
        saving, extracting, and initiating processing (parsing, embedding, storage).

        Args:
            zip_file (UploadFile): The uploaded zip file.
            description (str): Description of the codebase.

        Returns:
            list[str]: A list of file paths that were extracted.

        """
        print("Started codebase Processing")
        # project_path = r"D:/codes/langGraph_venv/code_assistant/temp_code_uploads/leave-management-laravel"
        project_path =  self.save_uploaded_zip(zip_file, description)
        result = await self.process_codebase(project_path, description)
        return True

    
    

    async def process_codebase(self, project_path: str, description: str) -> List[ChunkResponse]: # Adjusted return type for clarity, though caller ignores it
        # self.lang_processor = LaravelProcessor(project_path)
        # chunks = self.lang_processor.chunk_codebase()

        self.php_processor = LaravelProcessor()
        code_chunks: List[CodeChunk] = self.php_processor.analyze_codebase(project_path)
        
        if not code_chunks:
            print("No code chunks were generated by the processor.")
            return [] # Return empty list if no chunks

        # Extract the actual code content for embedding
        contents_to_embed = [chunk.content for chunk in code_chunks]
        embeddings = self.embedding_model.embed_chunks(contents_to_embed)

        if not embeddings or len(embeddings) != len(code_chunks):
            print(f"Embedding failed or mismatch. Expected {len(code_chunks)} embeddings, got {len(embeddings) if embeddings else 0}.")
            return [] # Return empty list on embedding failure

        # Use the full chunk data (as dictionaries) for payloads in Qdrant
        payloads = [chunk.model_dump() for chunk in code_chunks] # Use .model_dump() for Pydantic models
        success = self.vector_store.save_embeddings(embeddings, payloads)

        if not success:
            print("Failed to save embeddings to vector store.")
            return [] # Return empty list on storage failure
        return code_chunks # Return the processed chunks

                            
    def save_uploaded_zip(self, file: UploadFile, description: str) -> str:
        """
        Saves the uploaded zip file, extracts its contents.
        Returns a list of full paths to the extracted files.
        """
        #create temp folder th root level of the project
        TEMP_DIR = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "temp_code_uploads")
        # Ensure TEMP_DIR exists (it should be created by main.py on startup)
        if not os.path.exists(TEMP_DIR):
            os.makedirs(TEMP_DIR, exist_ok=True)
            print(f"Warning: TEMP_DIR '{TEMP_DIR}' was created by api_router.py. It should ideally be managed by main.py startup.")


        extracted_file_paths = []
        temp_zip_path = os.path.join(TEMP_DIR, file.filename)
        # Ensure extraction path is unique if multiple zips with same name are uploaded (though current logic overwrites)
        extraction_base_name = os.path.splitext(file.filename)[0]
        extraction_path = os.path.join(TEMP_DIR, extraction_base_name)

        try:
            # Save the uploaded zip file
            with open(temp_zip_path, "wb") as buffer:
                shutil.copyfileobj(file.file, buffer)

            # Create extraction directory, removing if it already exists to ensure clean extraction
            if os.path.exists(extraction_path):
                shutil.rmtree(extraction_path)
            os.makedirs(extraction_path, exist_ok=True)

            with zipfile.ZipFile(temp_zip_path, 'r') as zip_ref:
                zip_ref.extractall(extraction_path)
                # Get list of extracted files (full paths)
                for item_name in zip_ref.namelist():
                    full_item_path = os.path.join(extraction_path, item_name)
                    extracted_file_paths.append(full_item_path)

            print(f"Received description for {file.filename}: {description}")
            print(f"Extracted files for {file.filename} to: {extraction_path}")

            # Clean up the temporary zip file after extraction
            os.remove(temp_zip_path)

        except Exception as e:
            # Clean up in case of error
            if os.path.exists(temp_zip_path):
                os.remove(temp_zip_path)
            # If extraction path was created but extraction failed or was partial, clean it up
            if os.path.exists(extraction_path) and not any(os.path.exists(p) for p in extracted_file_paths):
                shutil.rmtree(extraction_path)
            raise HTTPException(status_code=500, detail=f"Failed to process zip file '{file.filename}': {str(e)}")
        finally:
            # Ensure the file object is closed
            if hasattr(file, 'file') and file.file:
                file.file.close()

        return extraction_path

    def query_for_semantic_search(self, query: str, top_k: int = 5) -> QueryResponse:
        """
        Embeds the user query and searches for similar code chunks in Qdrant.

        Args:
            query (str): The user's question/query string.
            top_k (int): The number of top similar chunks to retrieve.

        Returns:
            QueryResponse: An object containing the original question, a list of
                           relevant chunk responses, and the count of found chunks.
        """
        original_user_query = query # Store the original query

        if not original_user_query:
            return QueryResponse(
                question=original_user_query, 
                llm_answer=LLMQueryResponse(explanation="Query was empty.", code_references=[]), 
                retrieved_chunks=[], 
                relevant_chunks_found=0)

        processed_query_for_search = original_user_query

        if self.llm_model:
            print(f"Analyzing query with LLM: '{original_user_query}'")
            try:
                # GeminiModel.analyze_query now returns a parsed UnifiedQueryAnalysis object
                analysis_result = self.llm_model.analyze_query(original_user_query)
                print(f"LLM analysis result: type='{analysis_result.type.value}', response='{analysis_result.response}'")

                if analysis_result.type == UserQueryAnalysisType.GENERAL_ANSWER:
                    print(f"LLM provided direct answer: {analysis_result.response}")
                    return QueryResponse(
                        question=original_user_query,
                        llm_answer=LLMQueryResponse(explanation=analysis_result.response, code_references=[]),
                        retrieved_chunks=[],
                        relevant_chunks_found=0
                    )
                elif analysis_result.type == UserQueryAnalysisType.REFINED_QUERY:
                    if analysis_result.response and analysis_result.response.strip():
                        processed_query_for_search = analysis_result.response
                        print(f"LLM refined query to: '{processed_query_for_search}'")
                    else:
                        print("LLM returned an empty refined query, using original.")
                else:
                    print(f"LLM analysis returned unknown type: '{analysis_result.type.value}'. Proceeding with original query.")

            except Exception as e:
                print(f"Error during LLM query analysis: {e}. Proceeding with original query.")
        else:
            print("LLM model not available for query pre-processing.")

        # --- Semantic Search with processed_query_for_search ---
        print(f"Embedding processed query for search: '{processed_query_for_search}'")
        query_embedding_list = self.embedding_model.embed_chunks([processed_query_for_search])

        if not query_embedding_list:
            print("Could not generate embedding for the query.")
            return QueryResponse(
                question=original_user_query, 
                llm_answer=LLMQueryResponse(explanation="Could not generate embedding for the query.", code_references=[]), 
                relevant_chunks_found=0, 
                retrieved_chunks=[])
        
        query_embedding = query_embedding_list[0]

        print(f"Searching Qdrant for top {top_k} similar chunks based on: '{processed_query_for_search}'")
        similar_chunks_payloads = self.vector_store.search_similar_chunks(embedding=query_embedding, limit=top_k)
        
        retrieved_chunk_responses: List[ChunkResponse] = []
        code_chunks_for_llm: List[Dict[str, str]] = []

        if similar_chunks_payloads:
            for payload in similar_chunks_payloads:
                file_name = payload.get("file_path", "Unknown")
                chunk_content = payload.get("content", "No content available for this chunk.")
                
                retrieved_chunk_responses.append(
                    ChunkResponse(file_name=file_name, chunk=chunk_content)
                )
                code_chunks_for_llm.append({
                    "file_path": file_name,
                    "content": chunk_content
                })
        
        # --- Generate Final Answer using LLM with context (if any) ---
        final_llm_answer: LLMQueryResponse # Type hint
        if self.llm_model:
            if code_chunks_for_llm: # If chunks were found
                print(f"Sending original query {original_user_query} and {len(code_chunks_for_llm)} chunks to LLM for final answer...")
                final_llm_answer = self.llm_model.generate_response(user_query=original_user_query, context_chunks=code_chunks_for_llm)
            else: # No relevant chunks found after search
                print(f"No relevant chunks found. Sending original query {original_user_query} to LLM without specific context chunks.")
                final_llm_answer = self.llm_model.generate_response(user_query=original_user_query, context_chunks=[])
        elif not self.llm_model: # LLM model was never available
            final_llm_answer = LLMQueryResponse(
                explanation="LLM model is not available to generate an answer.",
                code_references=[]
            )
        else: # Should not be reached if logic is correct, but as a fallback
            final_llm_answer = LLMQueryResponse(
                explanation="Could not generate an answer using the LLM due to an unexpected state.",
                code_references=[]
            )
        

        return QueryResponse(
            question=original_user_query, # Always return the original question
            llm_answer=final_llm_answer,
            retrieved_chunks=retrieved_chunk_responses,
            relevant_chunks_found=len(retrieved_chunk_responses)
        )
    

    def suggest_and_apply_code_update(self, query: str) -> Dict[str, Any]:
        """
        PoC method to suggest and apply code changes via diff.
        Skips LLM analysis type check and directly performs search -> diff generation -> diff application.
        """
        self.current_project_path='D:/codes/langGraph_venv/code_assistant'
        if not self.current_project_path:
            return {"status": "error", "message": "No codebase has been uploaded yet. Please upload a zip file first."}

        # 1. Perform Semantic Search
        processed_query_for_search = query # Skip analysis for PoC
        try:
            query_embedding_list = self.embedding_model.embed_chunks([processed_query_for_search])
        except Exception as e:
             return {"status": "error", "message": f"Error generating embedding for the query: {e}"}

        if not query_embedding_list:
            return {"status": "error", "message": "Could not generate embedding for the query."}

        query_embedding = query_embedding_list[0]
        print(f"Searching Qdrant for top chunks for update query: '{processed_query_for_search}'")
        similar_chunks_payloads = self.vector_store.search_similar_chunks(embedding=query_embedding, limit=5) # Limit can be adjusted

        if not similar_chunks_payloads:
             return {"status": "info", "message": "No relevant code chunks found for the query. Cannot suggest changes."}

        code_chunks_for_llm = [{
            "file_path": payload.get("file_path", "Unknown"),
            "content": payload.get("content", "No content available for this chunk."),
            "start_line": payload.get("start_line"), # Ensure this is consistently available
            "end_line": payload.get("end_line"),     # Ensure this is consistently available
            "type": payload.get("type"),   
            "name": payload.get("name")
            } for payload in similar_chunks_payloads]

        # code_chunks_for_llm = [{'file_path': 'D:\\codes\\langGraph_venv\\code_assistant\\temp_code_uploads\\leave-management-laravel\\routes\\web.php', 'content': "Route::post('/leaves/{id}/approve', [LeaveController::class, 'approve'])->name('leaves.approve')"}, {'file_path': 'D:\\codes\\langGraph_venv\\code_assistant\\temp_code_uploads\\leave-management-laravel\\app\\Http\\Controllers\\LeaveController.php', 'content': "public function approve($id) {\n        $leave = Leave::findOrFail($id);\n        $leave->status = 'approved';\n        $leave->save();\n        return back();\n    }"}, {'file_path': 'D:\\codes\\langGraph_venv\\code_assistant\\temp_code_uploads\\leave-management-laravel\\app\\Http\\Controllers\\LeaveController.php', 'content': "public function applyForm() {\n        return view('leave.apply');\n    }"}, {'file_path': 'D:\\codes\\langGraph_venv\\code_assistant\\temp_code_uploads\\leave-management-laravel\\resources\\views\\leave\\index.blade.php', 'content': '<h1>All Leave Applications</h1>\n@foreach($leaves as $leave)\n    <p>{{ $leave->employee_name }} | {{ $leave->start_date }} to {{ $leave->end_date }} | {{ $leave->status }}</p>\n    <form method="POST" action="{{ route(\'leaves.approve\', $leave->id) }}">@csrf<button>Approve</button></form>\n    <form method="POST" action="{{ route(\'leaves.reject\', $leave->id) }}">@csrf<button>Reject</button></form>\n@endforeach\n'}, {'file_path': 'D:\\codes\\langGraph_venv\\code_assistant\\temp_code_uploads\\leave-management-laravel\\app\\Http\\Controllers\\LeaveController.php', 'content': "public function index() {\n        return view('leave.index', ['leaves' => Leave::all()]);\n    }"}]
        try:
            diff_output = self.llm_model.generate_code_diff(user_query=query, context_chunks=code_chunks_for_llm)
            print(f"LLM generated diff:\n{diff_output}")
            # Basic check if LLM returned something that looks like a diff or an explanation
            if not diff_output or diff_output.strip().startswith("#") or not any(line.startswith(('--- ', '+++ ', '@@ ')) for line in diff_output.splitlines()):
                 return {"status": "info", "message": "LLM did not generate a valid diff.", "diff": diff_output}

        except Exception as e:
            return {"status": "error", "message": f"Error generating diff with LLM: {e}"}

        # 3. Apply the diff
        try:
            # Use the patch library function
            apply_results = self.apply_diff_with_unidiff(diff_output, self.current_project_path)
            # apply_results = self.apply_diff_with_patch_lib(diff_output, self.current_project_path)
            # apply_results = self.apply_diff_with_patch_command(diff_output, self.current_project_path)
            
            # Check if any patch application failed or warned
            overall_status = "success"
            messages = ["Code changes suggested and application attempted."]
            for res in apply_results:
                 messages.append(f"  File {res['file_path']}: {res['status']} - {res['message']}")
                 if res['status'] == 'error':
                      overall_status = "error"
                 elif res['status'] == 'warning' and overall_status != 'error':
                      overall_status = "warning"

            return {"status": overall_status, "message": "\n".join(messages), "diff": diff_output, "apply_results": apply_results}

        except Exception as e:
            # This catch is for errors *before* the patch library starts processing files
            return {"status": "error", "message": f"An unexpected error occurred before applying diff: {e}", "diff": diff_output}


    def apply_diff_with_patch_command(self, diff_content: str, project_root: str) -> List[Dict[str, Any]]:
        diff_path = os.path.join(project_root, "temp_patch.diff")
        with open(diff_path, "w", encoding="utf-8") as f:
            f.write(diff_content)

        try:
            result = subprocess.run(
                ["patch", "-p1", "-i", diff_path],
                cwd=project_root,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            if result.returncode == 0:
                return [{"status": "success", "message": result.stdout}]
            else:
                return [{"status": "error", "message": result.stderr}]
        finally:
            os.remove(diff_path)

    
    # Define apply_diff_with_patch_lib function here
    def apply_diff_with_patch_lib(self, diff_content: str, project_root: str) -> List[Dict[str, Any]]:
        """
        Applies a unified diff string to files within the project root using the 'patch' library.
        ... (function implementation as provided in the thought block above) ...
        """
        results = []
        try:
            # The patch library expects bytes or a file object
            # Use io.StringIO to treat the string as a file
            patch_file_like = io.StringIO(diff_content)
            # Need to reset the stream position to the beginning after creating it
            patch_file_like.seek(0)
            patch_set = PatchSet(patch_file_like)

            if not patch_set:
                 results.append({"file_path": "N/A", "status": "error", "message": "Could not parse diff content. The diff might be empty or malformed."})
                 return results

            for p_item in patch_set: # Renamed 'p' to 'p_item' to avoid conflict with 'patch' module
                # p_item.path is the path from the diff (e.g., 'a/app/file.php' or 'app/file.php')
                # We need to determine the actual target path relative to project_root
                # Assuming LLM generates paths like `a/path` and `b/path`, we strip the first component.
                # The patch library's `apply` method takes `root` and `strip`.
                # `strip=1` removes the 'a/' or 'b/' prefix.
                # `root=project_root` makes the library look for the file relative to this root.

                try:
                    target_file_relative_to_diff = p_item.path # This is like 'a/app/file.php'
                    path_components = target_file_relative_to_diff.split(os.sep)
                    
                    # Ensure path has at least 'a/' or 'b/' prefix and a filename
                    if len(path_components) < 2: 
                         results.append({"file_path": p_item.path, "status": "error", "message": f"Invalid path format in diff: {p_item.path}. Expected 'a/path/to/file' or 'b/path/to/file'."})
                         continue

                    target_file_relative_to_root = os.sep.join(path_components[1:])
                    target_file_absolute_path = os.path.join(project_root, target_file_relative_to_root)

                    if not os.path.exists(target_file_absolute_path) and not p_item.is_added_file():
                         results.append({"file_path": p_item.path, "status": "error", "message": f"Target file for modification not found: {target_file_absolute_path}"})
                         continue
                    
                    # Ensure parent directory exists for new files
                    if p_item.is_added_file():
                        os.makedirs(os.path.dirname(target_file_absolute_path), exist_ok=True)

                    print(f"Attempting to apply patch to: {target_file_absolute_path}")
                    success = p_item.apply(strip=1, root=project_root) 

                    if success is True:
                         results.append({"file_path": p_item.path, "status": "success", "message": "Patch applied successfully."})
                    elif success is False: 
                         results.append({"file_path": p_item.path, "status": "warning", "message": "Patch application failed or applied with fuzz (context lines might not have matched exactly)."})
                    else: 
                         results.append({"file_path": p_item.path, "status": "warning", "message": f"Patch application returned unexpected result: {success}"})

                except Exception as e_apply:
                     results.append({"file_path": p_item.path, "status": "error", "message": f"An unexpected error occurred during patch application for {p_item.path}: {e_apply}"})

        except Exception as e_parse:
            results.append({"file_path": "N/A", "status": "error", "message": f"Error parsing or processing diff content: {e_parse}"})

        return results
    
    def apply_diff_with_unidiff(self, diff_content: str, project_root: str) -> List[Dict[str, Any]]:
        """
        Applies a unified diff string to files within the project root using the 'unidiff' library.
        Returns a list of results indicating success or failure for each file.
        """
        results = []
        diff_path = os.path.join(project_root, "temp_patch.diff")
        with open(diff_path, "w", newline="\n", encoding="utf-8") as f:
            f.write(diff_content)

        try:
            with open(diff_path, "r", encoding="utf-8") as f:
                patch_set = PatchSet(f)
                print("Parsed OK", patch_set)

            for patched_file in patch_set:
                target_path =  patched_file.path
                # Strip 'a/' or 'b/' prefix if present
                # path_parts = patched_file.path.split(os.sep)
                # relative_path = os.sep.join(path_parts[1:]) if len(path_parts) > 1 and path_parts[0] in ("a", "b") else patched_file.path
                # target_path = f"{project_root}/{relative_path}"

                if patched_file.is_removed_file:
                    if os.path.exists(target_path):
                        os.remove(target_path)
                        results.append({"file_path": target_path, "status": "success", "message": "File removed."})
                    else:
                        results.append({"file_path": target_path, "status": "warning", "message": "File marked for removal not found."})
                    continue

                if not patched_file.is_added_file and not os.path.exists(target_path):
                    results.append({"file_path": target_path, "status": "error", "message": "Original file does not exist."})
                    continue

                if patched_file.is_added_file:
                    os.makedirs(os.path.dirname(target_path), exist_ok=True)
                    original_lines = []
                else:
                    with open(target_path, "r", encoding="utf-8") as f:
                        original_lines = f.readlines()

                patched_lines = original_lines.copy()
                line_offset = 0

                for hunk in patched_file:
                    # Calculate the start of the hunk in the file
                    hunk_start = hunk.source_start - 1 + line_offset
                    # Extract only the lines from the hunk that are context or removed
                    expected_lines = [line.value for line in hunk if line.is_context or line.is_removed]
                    # Extract lines from the actual file at that point
                    actual_lines = patched_lines[hunk_start:hunk_start + len(expected_lines)]

                    def normalize(line: str):
                        line = line.replace('\t', '    ')             # Convert tabs to spaces
                        line = re.sub(r'\s*\{', ' {', line)           # Collapse spaces before {
                        return line.strip()
                       
                    
                    def is_similar(a: str, b: str, threshold: float = 0.95) -> bool:
                        return SequenceMatcher(None, normalize(a), normalize(b)).ratio() >= threshold
                    
                    # macthing diff content with original code for safe updation
                    matched = all(
                        is_similar(exp, act)
                        for exp, act in zip(expected_lines, actual_lines)
                    )

                    # for old_line, patch_line in zip([line for line in hunk if line.is_context or line.is_removed], actual_lines):
                    #     print(f"LINE: {normalize(old_line.value)}\nline: {normalize(patch_line)}")
                    #     if normalize(old_line.value) != normalize(patch_line):
                    #         break

                        
                    if not matched:
                        results.append({"file_path": target_path, "status": "error", "message": f"Hunk did not match context lines at line {hunk_start + 1}"})
                        break

                    # Apply hunk
                    hunk_len = len(expected_lines) or hunk.source_length
                    new_lines = [line.value for line in hunk if line.is_context or line.is_added]
                    patched_lines[hunk_start:hunk_start + hunk_len] = new_lines
                    line_offset += len(new_lines) - hunk_len

                else:
                    # Write back modified file if all hunks applied
                    # runs if the for loop for pacthed files runs successfully
                    with open(target_path, "w", encoding="utf-8") as f:
                        f.writelines(patched_lines)
                    results.append({"file_path": target_path, "status": "success", "message": "Patch applied."})

        except Exception as e:
            results.append({"file_path": "N/A", "status": "error", "message": str(e)})

        return results